module fp_adder_checker (
    input logic [31:0] fp_a,
    input logic [31:0] fp_b,
    input logic [2:0]  r_mode,
    input logic [31:0] fp_result,
    input logic        overflow,
    input logic        underflow,

    input logic [23:0] mantissa_a,
    input logic [23:0] mantissa_b,
    input logic [7:0]  exponent_a,
    input logic [7:0]  exponent_b,
    input logic [23:0] mantissa_a_aligned,
    input logic [23:0] mantissa_b_aligned,
    input logic [7:0]  exponent_common
);

  // 0 + 0 = 0
  always_comb begin
    CHK_ZERO_SUM: assert ((fp_a == 32'h00000000 && fp_b == 32'h00000000) ->
                          (fp_result == 32'h00000000 && overflow == 0 && underflow == 0));
  end

  // mantissa_b alineada si exponent_a > exponent_b
  always_comb begin
    CHK_ALIGN_B: assert ((exponent_a > exponent_b) ->
                         (mantissa_b_aligned == (mantissa_b >> (exponent_a - exponent_b))));
  end

  // mantissa_a alineada si exponent_b > exponent_a
  always_comb begin
    CHK_ALIGN_A: assert ((exponent_b > exponent_a) ->
                         (mantissa_a_aligned == (mantissa_a >> (exponent_b - exponent_a))));
  end

  // exponente resultante es el mÃ¡ximo
  always_comb begin
    CHK_EXP_COMMON: assert (exponent_common == $max(exponent_a, exponent_b));
  end

  // 0 + 0 = 0
  always_comb begin
    CHK_ZERO_SUM: assert ((fp_a == 32'h41800000 && fp_b == 32'h40000000) ->
                          (fp_result == 32'h41900000 && overflow == 0 && underflow == 0));
  end

endmodule

module fp_adder_checker (

//se침ales del top sumador
  input logic [31:0]  fp_a,
  input logic [31:0]  fp_b,
  input logic [2:0]   r_mode,
  input logic [31:0]  fp_result,
  input logic         overflow,
  input logic         underflow,

//se침ales de bloque fp_unpack

  input logic         sign_a,
  input logic         sign_b,
  input logic [7:0]   exponent_a,
  input logic [7:0]   exponent_b,
  input logic [23:0]  mantissa_a,
  input logic [23:0]  mantissa_b,
  input logic         is_special_a, 
  input logic         is_special_b,
  input logic         is_subnormal_a,
  input logic         is_subnormal_b,
  input logic         is_zero_a, 
  input logic         is_zero_b,

//se침ales de bloque align_exponents

  input logic [23:0]  mantissa_a_aligned,
  input logic [23:0]  mantissa_b_aligned,
  input logic [7:0]   exponent_common,

//Sub_mantisas
  input logic         result_sign,
  input logic [24:0]  mantissa_sum,

//Normalize
  input logic [7:0]   exponent_out, 
  input logic [26:0]  mantissa_ext,

//
  input logic         exponent_final,

  input logic [22:0]  mantissa_rounded,
  input logic         carry_out,
  input logic         overflow_internal,
  input logic [31:0]  fp_result_wire
);

  // 0 + 0 = 0
  always_comb begin
    ZERO_SUM: assert ((fp_a == 32'h00000000 && fp_b == 32'h00000000) ->
                          (fp_result == 32'h00000000 && overflow == 0 && underflow == 0));
  end
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  //fp_unpack de cada valor es el correcto
  always_comb begin
    FP_UNPACK_A: assert (((fp_a[30:23] != 8'hFF) && (fp_a[30:0] != 31'd0)) ->
                          ((sign_a == fp_a[31]) && (exponent_a == fp_a[30:23]) && (mantissa_a == {|fp_a[30:23], fp_a[22:0]})));
  end

  always_comb begin
    FP_UNPACK_B: assert (((fp_b[30:23] != 8'hFF) && (fp_b[30:0] != 31'd0)) ->
                          ((sign_b == fp_b[31]) && (exponent_b == fp_b[30:23]) && (mantissa_b == {|fp_b[30:23], fp_b[22:0]})));
  end

  always_comb begin
    FP_UNPACK_A_SPECIAL: assert ((fp_a[30:23] == 8'hFF) ->
                          ((sign_a == fp_a[31]) && (exponent_a == 8'hFF) && (mantissa_a == {1'b0, fp_a[22:0]})));
  end

  always_comb begin
    FP_UNPACK_B_SPECIAL: assert ((fp_b[30:23] == 8'hFF) ->
                          ((sign_b == fp_b[31]) && (exponent_b == 8'hFF) && (mantissa_b == {1'b0, fp_b[22:0]})));
  end
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  // mantissa_b alineada si exponent_a > exponent_b
  always_comb begin
    ALIGN_B: assert ((exponent_a > exponent_b) ->
                     (mantissa_b_aligned == (mantissa_b >> (exponent_a - exponent_b))));
end
  // mantissa_a alineada si exponent_b > exponent_a
always_comb begin
    ALIGN_A: assert ((exponent_b > exponent_a) ->
                     (mantissa_a_aligned == (mantissa_a >> (exponent_b - exponent_a))));
end

  always_comb begin
    ALIGN_NORMAL: assert (((exponent_b > exponent_a) && !(is_subnormal_a || is_subnormal_b)) ->
                         (mantissa_a_aligned == (mantissa_a >> (exponent_b - exponent_a))));
  end

  // exponente resultante es el m치ximo
  always_comb begin
    ALIGN_EXP_NORMAL: assert (!(is_subnormal_a && is_subnormal_b) -> (exponent_common) == ((exponent_a > exponent_b) ? exponent_a : exponent_b));
  end

  // exponente en ambos numeros subnormales
  always_comb begin
    ALIGN_EXP_SUBNORMAL: assert ((is_subnormal_a && is_subnormal_b) -> (exponent_common) == 8'd0);
  end
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  //Suma de mantisas
  always_comb begin
    SUMA: assert ((sign_a == sign_b) -> ((mantissa_sum == mantissa_a_aligned + mantissa_b_aligned) && (result_sign == sign_b)));
  end

  //Resta de mantisas
  always_comb begin
    SUMA_RESTA: assert ((sign_a != sign_b) -> 
    (mantissa_sum == (mantissa_a_aligned >= mantissa_b_aligned) ? (mantissa_a_aligned - mantissa_b_aligned) : (mantissa_b_aligned - mantissa_a_aligned)));
  end
  always_comb begin
    SUMA_SIGNO_RESTA: assert ((sign_a != sign_b) -> 
                (result_sign == (mantissa_a_aligned > mantissa_b_aligned) ? sign_a : sign_b));
  end

  always_comb begin
    SUMA_SIGNO_RESTA_IGUALES: assert ((sign_a != sign_b && (mantissa_a_aligned == mantissa_b_aligned)) -> 
                (result_sign == 0));
  end
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  //Si hay carry de la suma ajusta la mantizza
  always_comb begin
    NORM_CARRY_EXPO: assert ((mantissa_sum[24]) -> 
                ((exponent_out == exponent_common + 1)));
  end
  always_comb begin
  logic [7:0]  shift;
  logic [23:0] mantissa_shifted_check;
  shift = leading_zero_count(mantissa_sum[23:0]);
  mantissa_shifted_check = mantissa_sum[23:0] << shift;
    NORM_estupides: assert (((exponent_common > shift_amount) && mantissa_shifted_check[23]));
  end
  //Si hay carry de la suma aumneta exponente en normalize
  always_comb begin
    NORM_CARRY_MANTISSA: assert ((mantissa_sum[24]) -> 
                ((mantissa_ext == {mantissa_sum,1'b0,1'b0})));  //{1'b0,mantissa_sum,1'b0}
  end

  //ajuste normalize poner el primer 1 con shift a la derecha
  always_comb begin
    logic [47:0] mantissa_preshift;
    logic [7:0] shift_sub = leading_zero_count(mantissa_sum[23:0]);
    mantissa_preshift = {1'b0, mantissa_sum, 22'd0} << shift_sub;
    NORM_SHIFT_MANTISSA_NORMALES: assert (((mantissa_sum != 0) 
                                && (!mantissa_sum[24]) 
                                && (exponent_common > leading_zero_count(mantissa_sum[23:0]))) ->

              (mantissa_ext[26:3] == mantissa_preshift[46:23]));
  end

  always_comb begin
    NORM_SHIFT_EXPO_NORMALES: assert (((mantissa_sum != 0) 
                                && (!mantissa_sum[24]) 
                                && (exponent_common > leading_zero_count(mantissa_sum[23:0]))) ->

              ((exponent_out == exponent_common - leading_zero_count(mantissa_sum[23:0]))));
  end

//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  // 5 + 10 = 15 prueba de samuel
  always_comb begin
    SUM_15: assert ((fp_a == 32'h40a00000 && fp_b == 32'h41200000 && r_mode == 3'b001) ->
                          (fp_result == 32'h41700000 && overflow == 0 && underflow == 0));
  end
endmodule
